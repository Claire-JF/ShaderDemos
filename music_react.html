<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>GLSL Music Shader</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/atom-one-dark.min.css" />
  <style>
    :root {
      --panel-bg: rgba(22,22,24,0.55);
      --panel-border: rgba(255,255,255,0.16);
      --panel-shadow: 0 8px 30px rgba(0,0,0,0.45);
      --text: #eaeaf0;
      --muted: #9aa0a6;
      --accent: #6ee7b7;
      --accent-2: #93c5fd;
      --thumb: #ffffff;
      --track: rgba(255,255,255,0.2);
      --track-fill: linear-gradient(90deg, rgba(147,197,253,0.9), rgba(110,231,183,0.9));
    }

    .panel.glass {
      position: fixed; bottom: 18px; right: 18px; z-index: 30;
      color: var(--text);
      min-width: 260px; max-width: 320px;
      border-radius: 14px; padding: 12px 14px;
      background: var(--panel-bg);
      border: 1px solid var(--panel-border);
      box-shadow: var(--panel-shadow);
      backdrop-filter: blur(10px);
    }

    /* Mobile: move controls to top center to avoid covering buttons */
    @media (max-width: 768px) {
      .panel.glass {
        top: 56px;
        left: 50%;
        right: auto;
        bottom: auto;
        transform: translateX(-50%);
        min-width: 180px;
        max-width: 220px;
        padding: 6px 8px;
        border-radius: 8px;
      }

      .panel-header { gap: .35rem; margin-bottom: .25rem; }
      .panel-header .title { font-size: 10px; }
      .dot { width: 6px; height: 6px; }
      .controls { gap: .4rem; }
      .slider { gap: .2rem; }
      .row { font-size: 9px; }
      .icon-btn { width: 24px; height: 24px; }

      input[type="range"]{ height: 16px; }
      input[type="range"]::-webkit-slider-runnable-track{ height:3px; }
      input[type="range"]::-webkit-slider-thumb{ width:10px; height:10px; margin-top:-3.5px; }
      input[type="range"]::-moz-range-track{ height:3px; }
      input[type="range"]::-moz-range-thumb{ width:10px; height:10px; }
    }

    .panel-header { display:flex; align-items:center; gap:.5rem; margin-bottom:.4rem; }
    .panel-header .title { font-weight: 600; letter-spacing: .02em; font-size: 13px; color: var(--text); }
    .dot { width:8px; height:8px; border-radius:999px; display:inline-block; box-shadow:0 0 0 2px rgba(0,0,0,0.25) inset; }
    .dot-green { background: var(--accent); }

    .controls { display:flex; flex-direction:column; gap:.75rem; }
    .buttons { display:flex; justify-content:center; }
    .icon-btn {
      width:38px; height:38px; border-radius:999px; cursor:pointer;
      border:1px solid var(--panel-border);
      background: radial-gradient(120% 120% at 30% 20%, rgba(255,255,255,0.15), rgba(255,255,255,0.05));
      color:#fff; font-weight:700; line-height:1; display:flex; align-items:center; justify-content:center;
      transition: transform .1s ease, box-shadow .2s ease, background .2s ease;
    }
    .icon-btn:hover { transform: translateY(-1px); box-shadow: 0 6px 16px rgba(0,0,0,0.35); }
    .icon-btn:active { transform: translateY(0); }

    .slider { display:flex; flex-direction:column; gap:.35rem; }
    .row { display:flex; align-items:center; justify-content:space-between; font-size:12px; color: var(--muted); }
    .row label { color: var(--text); font-weight:500; }
    .row .val { color: var(--accent-2); font-variant-numeric: tabular-nums; }

    input[type="range"]{ -webkit-appearance:none; width:100%; height: 24px; background: transparent; }
    input[type="range"]::-webkit-slider-runnable-track{ height:6px; border-radius:999px; background: var(--track); overflow:hidden; }
    input[type="range"]::-webkit-slider-thumb{ -webkit-appearance:none; width:16px; height:16px; border-radius:999px; margin-top:-5px; background: var(--thumb); border:1px solid rgba(0,0,0,0.2); box-shadow: 0 2px 8px rgba(0,0,0,0.35); }
    input[type="range"]::-moz-range-track{ height:6px; border-radius:999px; background: var(--track); }
    input[type="range"]::-moz-range-thumb{ width:16px; height:16px; border-radius:999px; background: var(--thumb); border:1px solid rgba(0,0,0,0.2); box-shadow:0 2px 8px rgba(0,0,0,0.35); }

    /* Ensure overlay, tag, and toggle sit above canvas */
    html, body { margin: 0; height: 100%; overflow: hidden; background: #000; font-family: system-ui, sans-serif; }
    canvas { position: fixed; inset: 0; width: 100vw; height: 100dvh; display: block; touch-action: none; }
    #codePanel { position: fixed; left: 0; right: 0; bottom: -60%; height: 60%; background: rgba(20,20,20,0.97); color:#fff; backdrop-filter: blur(8px); border-top:1px solid rgba(255,255,255,.2); padding:1rem; box-sizing:border-box; transition: bottom .3s ease; z-index:10; overflow:auto; touch-action: pan-y; }
    #codePanel.open { bottom: 0; }
    #toggleBtn { position: fixed; bottom: 15px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.7); color:#fff; border:none; padding:.8rem 1.6rem; border-radius:999px; font-weight:600; cursor:pointer; z-index:20; }
    pre { margin:0; font-size:13px; line-height:1.5; overflow-x:auto; }
    #loadingOverlay {
      position: fixed; inset: 0; display: flex; align-items: center; justify-content: center;
      background: radial-gradient(ellipse at center, rgba(0,0,0,0.65), rgba(0,0,0,0.9));
      color: #fff; z-index: 40; transition: opacity .25s ease, visibility .25s ease; opacity: 1; visibility: visible;
    }
    #loadingOverlay.hidden { opacity: 0; visibility: hidden; }
    #loadingBox { display: flex; align-items: center; gap: .75rem; padding: .9rem 1.1rem; border-radius: 12px;
      background: rgba(30,30,30,0.65); border:1px solid rgba(255,255,255,0.2); box-shadow: 0 6px 24px rgba(0,0,0,0.35);
      backdrop-filter: blur(6px);
    }
    .spinner { width: 18px; height: 18px; border: 2px solid rgba(255,255,255,0.35); border-top-color: #fff; border-radius: 50%;
      animation: spin 0.9s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }
    #brandTag {
      position: fixed; top: 14px; right: 16px; z-index: 30;
      padding: .4rem .75rem; border-radius: 999px; background: transparent;
      border: 1px solid rgba(255,255,255,0.28);
      color: #ffffff; font-weight: 600; letter-spacing: .12em; text-transform: uppercase;
      font-size: 12px; line-height: 1; pointer-events: none; user-select: none;
      text-shadow: 0 1px 6px rgba(0,0,0,0.55);
      box-shadow: 0 2px 10px rgba(0,0,0,0.25);
    }
    /* removed audioPlayer UI */
    #error {
      position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: rgba(200,0,0,0.9); color: #fff; padding: 1rem 2rem;
      border-radius: 8px; display: none; z-index: 50; max-width: 80%;
    }
  </style>
</head>
<body>
  <canvas id="glslCanvas"></canvas>
  <!-- audio element removed; using programmatic Audio() -->
  
  <div id="controlPanel" class="panel glass">
    <div class="panel-header">
      <span class="dot dot-green"></span>
      <span class="title">Controls</span>
    </div>
    <div class="controls">
      <div class="buttons">
        <button id="playToggle" class="icon-btn" title="Play" aria-label="Play">▶</button>
        <button id="songToggle" class="icon-btn" title="Switch Song" aria-label="Switch Song" style="margin-left:8px;">⇆</button>
      </div>
      <div class="slider">
        <div class="row">
          <label for="thicknessScale">Thickness</label>
          <span id="thicknessVal" class="val">1.0x</span>
        </div>
        <input type="range" id="thicknessScale" min="0.1" max="3" step="0.1" value="1.0">
      </div>
      <div class="slider">
        <div class="row">
          <label for="movementScale">Movement</label>
          <span id="movementVal" class="val">1.0x</span>
        </div>
        <input type="range" id="movementScale" min="0.1" max="5" step="0.1" value="1.0">
      </div>
    </div>
  </div>

  <div id="loadingOverlay" aria-live="polite">
    <div id="loadingBox">
      <div class="spinner" aria-hidden="true"></div>
      <div id="loadingText">Loading shader…</div>
    </div>
  </div>

  <div id="error"></div>
  <button id="toggleBtn">Show Code</button>
  <div id="codePanel"><pre><code class="language-glsl" id="shaderCode"></code></pre></div>
  <div id="brandTag">Claire Wang</div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/languages/glsl.min.js"></script>

  <script>
    const canvas = document.getElementById('glslCanvas');
    const panel = document.getElementById('codePanel');
    const toggle = document.getElementById('toggleBtn');
    const codeEl = document.getElementById('shaderCode');
    const overlay = document.getElementById('loadingOverlay');
    const errorEl = document.getElementById('error');
    // 使用本地音频（程序创建，不在 DOM 中显示）
    const songs = ['./Sunflower.mp3', './SelfLove.mp3'];
    let songIndex = 0;
    const audio = new Audio(songs[songIndex]);
    audio.crossOrigin = 'anonymous';
    audio.preload = 'auto';
    audio.muted = true; // improve autoplay success
    audio.load();
    
    // dpr recalculated on every resize for mobile zoom/orientation
    let gl, program, soundTex, audioInitialized = false;
    let startTime = Date.now();

    function showError(msg) {
      console.error(msg);
      errorEl.textContent = msg;
      errorEl.style.display = 'block';
    }

    const vertexShaderSource = `
    #define PI radians(180.0)
    
    attribute float vertexId;
    uniform float time;
    uniform vec2 resolution;
    uniform sampler2D sound;
    uniform float thicknessScale;
    uniform float movementScale;
    
    varying vec4 v_color;
    
    //HSV to RGB (branchless), H in [0,1), S,V in [0,1]
    vec3 hsv2rgb(vec3 c) {
      c = vec3(c.x, clamp(c.yz, 0.0, 1.0));
      vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
      vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
      return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
    }
   // 4×4 Transform helpers
    mat4 ident() {
      return mat4(
        1, 0, 0, 0,
        0, 1, 0, 0,
        0, 0, 1, 0,
        0, 0, 0, 1);
    }

    mat4 scale(vec3 s) {
      return mat4(
        s[0], 0, 0, 0,
        0, s[1], 0, 0,
        0, 0, s[2], 0,
        0, 0, 0, 1);
    }

    float hash(float p) {
      vec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));
      p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));
      return fract(p2.x * p2.y * 95.4337);
    }
    
    // Map [0,1] → [-1,1]
    float m1p1(float v) {
      return v * 2. - 1.;
    }
    // Complement
    float inv(float v) {
      return 1. - v;
    }
    
    // Assign id and a 2D seed from audio, produce a smooth points line.
    // Multiple sin/cos with different frequencies → non-repeating path.
    vec3 getCenterPoint(const float id, vec2 seed) {
      float a0 = id + seed.x;
      float a1 = id + seed.y;
      return vec3(
        (sin(a0 * 0.39) + sin(a0 * 0.73) + sin(a0 * 1.27)) / 3.,
        (sin(a1 * 0.43) + sin(a1 * 0.37) + cos(a1 * 1.73)) / 3., //keeps output within [-1,1]
        0);
    }
    
    // ─────────────────────────────────────────────────────────────────────────────
    // Extrude one quad (two triangles, 6 vertices) along the curve centerline
    //   quadId   : quad# along the line
    //   pointId  : which of the 6 vertices (0..5) in this quad
    //   thickness: half-width of the ribbon at this segment (audio-driven)
    //   seed     : audio-driven phase offset for centerline noise
    //   pos      : (out) generated vertex position (object space)
    //   uv       : (out) quad-local (u,v) in {0,1}×{0,1}
    // ─────────────────────────────────────────────────────────────────────────────
    void getQuadPoint(const float quadId, const float pointId, float thickness, vec2 seed, out vec3 pos, out vec2 uv) {
      // Sample four nearby center points to estimate tangents robustly (central diff).
      // p1→p2 is the current center segment; p0,p3 used for tangent line calculation.
      vec3 p0 = getCenterPoint(quadId + 0.0, seed);
      vec3 p1 = getCenterPoint(quadId + 0.1, seed);
      vec3 p2 = getCenterPoint(quadId + 0.2, seed);
      vec3 p3 = getCenterPoint(quadId + 0.3, seed);
      
      // Compute tangents: (dx,dy)->(-dy,dx))
      vec3 perp0 = normalize(p2 - p0).yxz * vec3(-1, 1, 0) * thickness;
      vec3 perp1 = normalize(p3 - p1).yxz * vec3(-1, 1, 0) * thickness;

      // Map the 6 vertex indices of a quad to two flags (avoid branching)
      //  ux ∈ {0,1} → left/right side, vy ∈ {0,1} → near p1 / near p2
      float id = pointId;
      float ux = mod(id, 2.);
      float vy = mod(floor(id / 2.) + floor(id / 3.), 2.);

      // Compose final position:
      // 1) Interpolate along the centerline: p1 → p2 by vy
      // 2) Interpolate normals (perp0→perp1) by vy for smooth width/turn transitions
      // 3) Pick left/right with ux ∈ {0,1} mapping to {-1,+1}
      pos = vec3(mix(p1, p2, vy) + mix(-1., 1., ux) * mix(perp0, perp1, vy)); 
      uv  = vec2(ux, vy);
    }

    #define POINTS_PER_LINE 1800.
    #define QUADS_PER_LINE (POINTS_PER_LINE / 6.)

    void main() {
      float lineId = floor(vertexId / POINTS_PER_LINE);
      float quadCount = POINTS_PER_LINE / 6.; 
      float pointId = mod(vertexId, 6.);
      float quadId = floor(mod(vertexId, POINTS_PER_LINE) / 6.);
      vec3 pos;
      vec2 uv;
      
      // Read from audio texture
      float snd0 = texture2D(sound, vec2(0.13 + lineId * 0.05, quadId / quadCount * 0.01)).a; //low freq -> drum/bass
      float snd1 = texture2D(sound, vec2(0.14 + lineId * 0.05, quadId / quadCount * 0.01)).a; //high freq -> vocal & others
      
      // Map audio to thickness
      // pow(,5): small values shrink, peaks stand out.
      float sndAdjusted0 = pow(snd0, 5.0) * thicknessScale;

      // Generate ribbon geometry for this vertex (one corner of current quad)
      // Curve parameter = quadId*0.02 + temporal drift (time*...)
      //  - 0.02 makes adjacent segments close in param-space → smooth curve.
      getQuadPoint(
        quadId * 0.02 + time * 3.1 * (lineId + 1.), 
        pointId, 
        sndAdjusted0 * 0.25, 
        vec2(pow(snd0, 2.), pow(snd1, 2.0)), 
        pos, 
        uv
      );  

      //Aspect-ratio correction
      vec3 aspect = vec3(resolution.y / resolution.x, 1, 1);

      // Project to clip space
      mat4 mat = ident(); 
      mat *= scale(aspect);
      gl_Position = vec4((mat * vec4(pos, 1)).xyz, 1);

      // Push segments gradually in Z to create subtle layering
      gl_Position.z = -m1p1(quadId / quadCount); // map 0..1 → -1..1, then negate → [-1,0]

      //  spread lines across X by lineId
      //  add small audio-driven sway using snd0 & 1
      gl_Position.x += m1p1(lineId / 10.) * 0.4 + (snd1 * snd0) * 0.10 * movementScale;
      
      gl_PointSize = 4.;

      // Per-vertex color: hue per-line, alpha grows along the line (for fade)
      float hue = mix(0.95, 1.5, lineId * 0.1);
      float sat = 1.;
      float val = 1.;

      // multiply back into RGB for soft tailing
      v_color = vec4(hsv2rgb(vec3(hue, sat, val)), quadId / quadCount);
      v_color = vec4(v_color.rgb * v_color.a, v_color.a);
    }`;

    const fragmentShaderSource = `
    precision mediump float;
    varying vec4 v_color;
    void main(){ 
      gl_FragColor = v_color; 
    }`;

    // 初始化 WebGL
    gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    if (!gl) {
      showError('WebGL not supported');
      overlay.classList.add('hidden');
    }

    // 编译 shader
    function compileShader(source, type) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        const info = gl.getShaderInfoLog(shader);
        showError('Shader compile error: ' + info);
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
    const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);

    if (vertexShader && fragmentShader) {
      program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);

      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        showError('Program link error: ' + gl.getProgramInfoLog(program));
      }
    }

    // 获取 locations
    const vertexIdLoc = gl.getAttribLocation(program, 'vertexId');
    const timeLoc = gl.getUniformLocation(program, 'time');
    const resolutionLoc = gl.getUniformLocation(program, 'resolution');
    const soundLoc = gl.getUniformLocation(program, 'sound');
    const thicknessScaleLoc = gl.getUniformLocation(program, 'thicknessScale');
    const movementScaleLoc = gl.getUniformLocation(program, 'movementScale');
    // sensitivity uniform removed

    // Control values
    let thicknessScale = 1.0;
    let movementScale = 1.0;
    // sensitivity removed; fixed in shader as pow(..., 5.0)

    // 创建 vertexId buffer
    const vertexCount = 1800 * 3 * 6;
    const vertexIds = new Float32Array(vertexCount);
    for (let i = 0; i < vertexCount; i++) vertexIds[i] = i;
    
    const vertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertexIds, gl.STATIC_DRAW);

    // 创建初始音频纹理（与频谱分辨率匹配）
    const texWidth = 256; // analyser.frequencyBinCount (fftSize=512)
    const texHeight = 1;
    soundTex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, soundTex);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    
    const emptyPixels = new Uint8Array(texWidth * texHeight * 4);
    for (let i = 0; i < emptyPixels.length; i += 4) {
      emptyPixels[i] = 0;     // R
      emptyPixels[i+1] = 0;   // G
      emptyPixels[i+2] = 0;   // B
      emptyPixels[i+3] = 0;   // A carries audio amplitude
    }
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texWidth, texHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, emptyPixels);

    // 音频设置
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const analyser = audioCtx.createAnalyser();
    analyser.fftSize = 512;
    analyser.smoothingTimeConstant = 0.5; // more rhythmic, less smear
    const freqData = new Uint8Array(analyser.frequencyBinCount);

    async function ensureAudioGraph() {
      if (!audioInitialized) {
        await audioCtx.resume();
        const src = audioCtx.createMediaElementSource(audio);
        src.connect(analyser);
        analyser.connect(audioCtx.destination);
        audioInitialized = true;
      }
    }

    async function tryAutoplay() {
      try {
        await ensureAudioGraph();
        // start muted to satisfy autoplay policies; try to unmute shortly after
        audio.muted = true;
        await audio.play();
        setTimeout(() => { try { audio.muted = false; } catch(_){} }, 300);
      } catch (e) {
        // fallback: keep muted if needed
        try {
          audio.muted = true;
          await ensureAudioGraph();
          await audio.play();
        } catch (e2) {
          console.warn('Autoplay blocked. Click the Play button to start.', e2);
        }
      }
    }

    function updateAudioTexture() {
      if (!audio.paused && audioInitialized) {
        analyser.getByteFrequencyData(freqData);
        const pixels = new Uint8Array(texWidth * texHeight * 4);

        const count = Math.min(freqData.length, texWidth);
        for (let i = 0; i < count; i++) {
          const v = freqData[i]; // 0..255
          const o = i * 4;
          pixels[o] = 0;      // R (unused)
          pixels[o+1] = 0;    // G (unused)
          pixels[o+2] = 0;    // B (unused)
          pixels[o+3] = v;    // A stores amplitude (shader samples .a)
        }

        gl.bindTexture(gl.TEXTURE_2D, soundTex);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texWidth, texHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
      }
    }

    // 渲染循环
    function render() {
      updateAudioTexture();
      
      gl.viewport(0, 0, canvas.width, canvas.height);
      gl.clearColor(0, 0, 0, 1);
      gl.clear(gl.COLOR_BUFFER_BIT);
      
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
      
      gl.useProgram(program);
      
      // 设置 uniforms
      const time = (Date.now() - startTime) / 1000;
      gl.uniform1f(timeLoc, time);
      gl.uniform2f(resolutionLoc, canvas.width, canvas.height);
      gl.uniform1f(thicknessScaleLoc, thicknessScale * 0.5);
      gl.uniform1f(movementScaleLoc, movementScale);
      // no sensitivity uniform
      
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, soundTex);
      gl.uniform1i(soundLoc, 0);
      
      // 绑定 vertexId attribute
      gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
      gl.enableVertexAttribArray(vertexIdLoc);
      gl.vertexAttribPointer(vertexIdLoc, 1, gl.FLOAT, false, 0, 0);
      
      // 绘制
      gl.drawArrays(gl.TRIANGLES, 0, vertexCount);
      
      requestAnimationFrame(render);
    }

    // 窗口大小调整
    function resizeCanvas() {
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      const w = Math.floor(rect.width * dpr);
      const h = Math.floor(rect.height * dpr);
      if (canvas.width !== w || canvas.height !== h) {
        canvas.width = w;
        canvas.height = h;
      }
    }

    window.addEventListener('resize', resizeCanvas);
    window.addEventListener('orientationchange', resizeCanvas);
    if (window.visualViewport) {
      window.visualViewport.addEventListener('resize', resizeCanvas);
    }
    resizeCanvas();

    // 启动
    overlay.classList.add('hidden');
    tryAutoplay(); // 尝试在加载结束自动播放
    // also attempt once audio is ready
    audio.addEventListener('canplay', () => { if (audio.paused) tryAutoplay(); }, { once: true });
    render();

    // UI 控制
    toggle.addEventListener('click', () => {
      const open = panel.classList.toggle('open');
      toggle.textContent = open ? 'Hide Code' : 'Show Code';
    });

    // Audio reactivity controls
    const thicknessSlider = document.getElementById('thicknessScale');
    const movementSlider = document.getElementById('movementScale');
    const thicknessVal = document.getElementById('thicknessVal');
    const movementVal = document.getElementById('movementVal');
    const playToggle = document.getElementById('playToggle');
    const songToggle = document.getElementById('songToggle');

    thicknessSlider.addEventListener('input', (e) => {
      thicknessScale = parseFloat(e.target.value);
      thicknessVal.textContent = thicknessScale.toFixed(1) + 'x';
    });

    movementSlider.addEventListener('input', (e) => {
      movementScale = parseFloat(e.target.value);
      movementVal.textContent = movementScale.toFixed(1) + 'x';
    });

    function syncPlayIcon() {
      const playing = !audio.paused;
      playToggle.textContent = playing ? '⏸' : '▶';
      playToggle.setAttribute('aria-label', playing ? 'Pause' : 'Play');
      playToggle.setAttribute('title', playing ? 'Pause' : 'Play');
    }

    playToggle.addEventListener('click', async () => {
      if (audio.paused) {
        await ensureAudioGraph();
        try {
          audio.muted = false; // ensure audible when user interacts
          await audio.play();
        } catch {}
      } else {
        audio.pause();
      }
      syncPlayIcon();
    });

    audio.addEventListener('play', syncPlayIcon);
    audio.addEventListener('pause', syncPlayIcon);
    syncPlayIcon();

    function updateSongToggleUI() {
      const name = songIndex === 0 ? 'Sunflower' : 'SelfLove';
      songToggle.setAttribute('title', `Switch Song (Now: ${name})`);
      songToggle.setAttribute('aria-label', `Switch Song (Now: ${name})`);
    }

    function setSong(index) {
      songIndex = index % songs.length;
      const wasPlaying = !audio.paused;
      audio.pause();
      audio.currentTime = 0;
      audio.src = songs[songIndex];
      audio.load();
      updateSongToggleUI();
      if (wasPlaying) {
        (async () => {
          try {
            await ensureAudioGraph();
            audio.muted = false;
            await audio.play();
          } catch {}
          syncPlayIcon();
        })();
      } else {
        syncPlayIcon();
      }
    }

    songToggle.addEventListener('click', () => {
      setSong(songIndex === 0 ? 1 : 0);
    });
    updateSongToggleUI();

    codeEl.textContent = vertexShaderSource;
    hljs.highlightElement(codeEl);
  </script>
</body>
</html>

