<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>GLSL Halo Capsule</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/atom-one-dark.min.css" />
  <style>
    html, body {
      margin: 0;
      /* Prefer dynamic viewport height on mobile to avoid URL bar jump */
      height: 100vh; /* fallback */
      height: 100dvh; /* modern browsers */
      overflow: hidden;
      background: #000;
      font-family: system-ui, sans-serif;
      overscroll-behavior: none;
    }
    canvas {
      width: 100vw;
      height: 100vh;  /* fallback */
      height: 100dvh; /* modern browsers */
      display: block;
      touch-action: none;
    }
    #codePanel { position: fixed; left: 0; right: 0; bottom: -60%; height: 60%; background: rgba(20,20,20,0.97); color:#fff; backdrop-filter: blur(8px); border-top:1px solid rgba(255,255,255,.2); padding:1rem; box-sizing:border-box; transition: bottom .3s ease; z-index:10; overflow:auto; touch-action: pan-y; }
    #codePanel.open { bottom: 0; }
    #toggleBtn { position: fixed; bottom: 15px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.7); color:#fff; border:none; padding:.8rem 1.6rem; border-radius:999px; font-weight:600; cursor:pointer; z-index:20; }
    pre { margin:0; font-size:13px; line-height:1.5; overflow-x:auto; }
    
    /* Loading overlay */
    #loadingOverlay {
      position: fixed; inset: 0; display: flex; align-items: center; justify-content: center;
      background: radial-gradient(ellipse at center, rgba(0,0,0,0.65), rgba(0,0,0,0.9));
      color: #fff; z-index: 40; transition: opacity .25s ease, visibility .25s ease; opacity: 1; visibility: visible;
    }
    #loadingOverlay.hidden { opacity: 0; visibility: hidden; }
    #loadingBox { display: flex; align-items: center; gap: .75rem; padding: .9rem 1.1rem; border-radius: 12px;
      background: rgba(30,30,30,0.65); border:1px solid rgba(255,255,255,0.2); box-shadow: 0 6px 24px rgba(0,0,0,0.35);
      backdrop-filter: blur(6px);
    }
    .spinner { width: 18px; height: 18px; border: 2px solid rgba(255,255,255,0.35); border-top-color: #fff; border-radius: 50%;
      animation: spin 0.9s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* Corner label: transparent background, subtle glow */
    #brandTag {
      position: fixed; top: 14px; right: 16px; z-index: 30;
      padding: .4rem .75rem; border-radius: 999px; background: transparent;
      border: 1px solid rgba(255,255,255,0.28);
      color: #ffffff; font-weight: 600; letter-spacing: .12em; text-transform: uppercase;
      font-size: 12px; line-height: 1; pointer-events: none; user-select: none;
      text-shadow: 0 1px 6px rgba(0,0,0,0.55);
      box-shadow: 0 2px 10px rgba(0,0,0,0.25);
    }
    @media (min-width: 640px) { #brandTag { font-size: 13px; } }
  </style>
</head>
<body>
  <canvas id="glslCanvas"></canvas>
  
  <!-- Loading overlay -->
  <div id="loadingOverlay" aria-live="polite">
    <div id="loadingBox">
      <div class="spinner" aria-hidden="true"></div>
      <div id="loadingText">Loading shader…</div>
    </div>
  </div>

  <button id="toggleBtn">Show Code</button>
  <div id="codePanel"><pre><code class="language-glsl" id="shaderCode"></code></pre></div>

  <!-- Top-right transparent label -->
  <div id="brandTag">Claire Wang</div>

  <script src="./GlslCanvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/languages/glsl.min.js"></script>
  <script>hljs.registerLanguage('glsl', hljsGrammarGlsl);</script>

  <script>
    const canvas = document.getElementById('glslCanvas');
    const panel  = document.getElementById('codePanel');
    const toggle = document.getElementById('toggleBtn');
    const codeEl = document.getElementById('shaderCode');
    let dpr = window.devicePixelRatio || 1;
    const overlay = document.getElementById('loadingOverlay');
    const loadingText = document.getElementById('loadingText');
    let sandbox;
    let pointerActive = false;
    let lastMouse = { x: 0, y: 0 };

    function resizeCanvas(){
      // Re-evaluate DPR on each resize (rotation/zoom changes it on mobile)
      dpr = window.devicePixelRatio || 1;
      // Use layout size from CSS pixels and scale by DPR for sharp rendering
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(1, Math.floor(rect.width * dpr));
      const h = Math.max(1, Math.floor(rect.height * dpr));
      if (canvas.width !== w || canvas.height !== h) {
        canvas.width = w; canvas.height = h;
        if (sandbox && sandbox.resize) sandbox.resize();
      }
    }
    // Listen to window resize, visual viewport changes (mobile URL bar), and orientation
    window.addEventListener('resize', resizeCanvas);
    if (window.visualViewport) window.visualViewport.addEventListener('resize', resizeCanvas);
    window.addEventListener('orientationchange', () => setTimeout(resizeCanvas, 50));
    // iOS: prevent pinch-zoom changing scale unexpectedly
    window.addEventListener('gesturestart', (e) => { e.preventDefault(); }, { passive: false });
    resizeCanvas();

    (async function boot(){
      try {
        overlay.classList.remove('hidden');
        sandbox = new GlslCanvas(canvas);
        const resp = await fetch('capsule.frag');
        if (!resp.ok) throw new Error('HTTP ' + resp.status + ' loading');
        const src = await resp.text();
        sandbox.load(src);
        resizeCanvas();
        codeEl.textContent = src;
        hljs.highlightElement(codeEl);
        // Wait a couple frames to ensure first render
        await new Promise(requestAnimationFrame);
        await new Promise(requestAnimationFrame);
        overlay.classList.add('hidden');
      } catch (err) {
        console.error(err);
        loadingText.textContent = 'Failed to load shader: ' + (err && err.message ? err.message : err);
      }
      // do not set u_mouse here; shader treats (0,0) as neutral
    })();

    let suppressNextClick = false;
    toggle.addEventListener('click', (ev) => {
      if (suppressNextClick) { suppressNextClick = false; return; }
      toggle.style.pointerEvents = 'none';
      const open = panel.classList.toggle('open');
      toggle.textContent = open ? 'Hide Code' : 'Show Code';
      if (toggle && toggle.blur) toggle.blur();
      resizeCanvas();
      pointerActive = false;
      // reset to neutral so clicks never imprint a position
      lastMouse.x = 0.0;
      lastMouse.y = 0.0;
      if (sandbox && sandbox.setUniform) sandbox.setUniform('u_mouse_user', 0.0, 0.0);
      setTimeout(() => { toggle.style.pointerEvents = 'auto'; }, 300);
    });


    // Minimal pointer → u_mouse bridge for mobile drag
    function setMouseFromPointerEvent(e){
      const rect = canvas.getBoundingClientRect();
      const cssX = e.clientX - rect.left;
      const cssY = e.clientY - rect.top;
      const x = cssX * dpr;
      const y = (rect.height - cssY) * dpr; // origin at bottom-left
      lastMouse.x = x;
      lastMouse.y = y;
      if (sandbox && sandbox.setUniform) sandbox.setUniform('u_mouse_user', lastMouse.x, lastMouse.y);
    }

    const passiveFalse = { passive: false };
    canvas.addEventListener('pointerdown', (e) => {
      if (e.pointerType === 'touch') e.preventDefault();
      pointerActive = true;
      try { canvas.setPointerCapture && canvas.setPointerCapture(e.pointerId); } catch {}
      if (e.pointerType === 'touch') toggle.style.pointerEvents = 'none';
      setMouseFromPointerEvent(e);
    }, passiveFalse);

    canvas.addEventListener('pointermove', (e) => {
      if (e.pointerType === 'touch') e.preventDefault();
      // Mobile: require active drag; Desktop: hover updates without click
      if (e.pointerType === 'touch' && !pointerActive) return;
      setMouseFromPointerEvent(e);
    }, passiveFalse);

    canvas.addEventListener('pointerup', (e) => {
      if (e.pointerType === 'touch') {
        e.preventDefault();
        pointerActive = false;
        try { canvas.releasePointerCapture && canvas.releasePointerCapture(e.pointerId); } catch {}
        toggle.style.pointerEvents = 'auto';
        lastMouse.x = 0.0; lastMouse.y = 0.0;
        if (sandbox && sandbox.setUniform) sandbox.setUniform('u_mouse_user', 0.0, 0.0);
      }
      // For mouse, do nothing special so hover continues
    }, passiveFalse);

    window.addEventListener('pointercancel', (e) => {
      if (e.pointerType === 'touch') {
        pointerActive = false;
        try { canvas.releasePointerCapture && canvas.releasePointerCapture(e.pointerId); } catch {}
        toggle.style.pointerEvents = 'auto';
        lastMouse.x = 0.0; lastMouse.y = 0.0;
        if (sandbox && sandbox.setUniform) sandbox.setUniform('u_mouse_user', 0.0, 0.0);
      }
    }, passiveFalse);

    // Desktop: clear effect when leaving the canvas
    canvas.addEventListener('pointerleave', (e) => {
      if (e.pointerType !== 'touch') {
        lastMouse.x = 0.0; lastMouse.y = 0.0;
        if (sandbox && sandbox.setUniform) sandbox.setUniform('u_mouse_user', 0.0, 0.0);
      }
    });

    // Forward pointer events from the code panel to the shader, so
    // the canvas remains interactive even when the panel is open.
    // We do NOT preventDefault here so the panel can still scroll.
    function panelPointerDown(e){
      pointerActive = true;
      setMouseFromPointerEvent(e);
    }
    function panelPointerMove(e){
      if (e.pointerType === 'touch' && !pointerActive) return;
      setMouseFromPointerEvent(e);
    }
    function panelPointerEnd(e){
      pointerActive = false;
      lastMouse.x = 0.0; lastMouse.y = 0.0;
      if (sandbox && sandbox.setUniform) sandbox.setUniform('u_mouse_user', 0.0, 0.0);
    }
    panel.addEventListener('pointerdown', panelPointerDown);
    panel.addEventListener('pointermove', panelPointerMove);
    panel.addEventListener('pointerup', panelPointerEnd);
    panel.addEventListener('pointercancel', panelPointerEnd);
  </script>
</body>
</html>
