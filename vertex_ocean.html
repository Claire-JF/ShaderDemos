<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>GLSL Vertex Ocean</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- highlight.js -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/atom-one-dark.min.css" />

  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; background: #000; font-family: system-ui, sans-serif; }
    canvas { width: 100%; height: 100%; display: block; touch-action: none; }

    /* Controls panel styling (match music_react.html) */
    :root {
      --panel-bg: rgba(22,22,24,0.55);
      --panel-border: rgba(255,255,255,0.16);
      --panel-shadow: 0 8px 30px rgba(0,0,0,0.45);
      --text: #eaeaf0;
      --muted: #9aa0a6;
      --accent: #6ee7b7;
      --accent-2: #93c5fd;
      --thumb: #ffffff;
      --track: rgba(255,255,255,0.2);
      --track-fill: linear-gradient(90deg, rgba(147,197,253,0.9), rgba(110,231,183,0.9));
    }

    .panel.glass {
      position: fixed; bottom: 14px; right: 14px; z-index: 30;
      color: var(--text);
      min-width: 220px; max-width: 280px;
      border-radius: 10px; padding: 10px 12px;
      background: var(--panel-bg);
      border: 1px solid var(--panel-border);
      box-shadow: var(--panel-shadow);
      backdrop-filter: blur(10px);
    }

    /* Mobile: move controls panel to top-center */
    @media (max-width: 640px), (hover: none) and (pointer: coarse) {
      .panel.glass {
        top: 14px; bottom: auto; right: auto; left: 50%;
        transform: translateX(-50%);
      }
    }

    .panel-header { display:flex; align-items:center; gap:.45rem; margin-bottom:.3rem; }
    .panel-header .title { font-weight: 600; letter-spacing: .02em; font-size: 11px; color: var(--text); }
    .dot { width:8px; height:8px; border-radius:999px; display:inline-block; box-shadow:0 0 0 2px rgba(0,0,0,0.25) inset; }
    .dot-green { background: var(--accent); }

    .controls { display:flex; flex-direction:column; gap:.55rem; }
    .buttons { display:none; }
    .slider { display:flex; flex-direction:column; gap:.25rem; }
    .row { display:flex; align-items:center; justify-content:space-between; font-size:11px; color: var(--muted); }
    .row label { color: var(--text); font-weight:500; }
    .row .val { color: var(--accent-2); font-variant-numeric: tabular-nums; }

    input[type="range"]{ -webkit-appearance:none; width:100%; height: 18px; background: transparent; }
    input[type="range"]::-webkit-slider-runnable-track{ height:4px; border-radius:999px; background: var(--track); overflow:hidden; }
    input[type="range"]::-webkit-slider-thumb{ -webkit-appearance:none; width:12px; height:12px; border-radius:999px; margin-top:-4px; background: var(--thumb); border:1px solid rgba(0,0,0,0.2); box-shadow: 0 2px 8px rgba(0,0,0,0.35); }
    input[type="range"]::-moz-range-track{ height:4px; border-radius:999px; background: var(--track); }
    input[type="range"]::-moz-range-thumb{ width:12px; height:12px; border-radius:999px; background: var(--thumb); border:1px solid rgba(0,0,0,0.2); box-shadow:0 2px 8px rgba(0,0,0,0.35); }

    /* Code panel */
    #codePanel { position: fixed; left: 0; right: 0; bottom: -60%; height: 60%; background: rgba(20,20,20,0.97); color:#fff; backdrop-filter: blur(8px); border-top:1px solid rgba(255,255,255,.2); padding:1rem; box-sizing:border-box; transition: bottom .3s ease; z-index:10; overflow:auto; touch-action: pan-y; }
    #codePanel.open { bottom: 0; }
    #toggleBtn { position: fixed; bottom: 15px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.7); color:#fff; border:none; padding:.8rem 1.6rem; border-radius:999px; font-weight:600; cursor:pointer; z-index:20; }
    pre { margin:0; font-size:13px; line-height:1.5; overflow-x:auto; }

    /* Loading overlay */
    #loadingOverlay {
      position: fixed; inset: 0; display: flex; align-items: center; justify-content: center;
      background: radial-gradient(ellipse at center, rgba(0,0,0,0.65), rgba(0,0,0,0.9));
      color: #fff; z-index: 40; transition: opacity .25s ease, visibility .25s ease; opacity: 1; visibility: visible;
    }
    #loadingOverlay.hidden { opacity: 0; visibility: hidden; }
    #loadingBox { display: flex; align-items: center; gap: .75rem; padding: .9rem 1.1rem; border-radius: 12px;
      background: rgba(30,30,30,0.65); border:1px solid rgba(255,255,255,0.2); box-shadow: 0 6px 24px rgba(0,0,0,0.35);
      backdrop-filter: blur(6px);
    }
    .spinner { width: 18px; height: 18px; border: 2px solid rgba(255,255,255,0.35); border-top-color: #fff; border-radius: 50%;
      animation: spin 0.9s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* Brand tag */
    #brandTag {
      position: fixed; top: 14px; right: 16px; z-index: 30;
      padding: .4rem .75rem; border-radius: 999px; background: transparent;
      border: 1px solid rgba(255,255,255,0.28);
      color: #ffffff; font-weight: 600; letter-spacing: .12em; text-transform: uppercase;
      font-size: 12px; line-height: 1; pointer-events: none; user-select: none;
      text-shadow: 0 1px 6px rgba(0,0,0,0.55);
      box-shadow: 0 2px 10px rgba(0,0,0,0.25);
    }
    @media (min-width: 640px) { #brandTag { font-size: 13px; } }
  </style>
</head>
<body>
  <canvas id="gl"></canvas>

  <!-- Controls panel (styled like music_react.html) -->
  <div id="controlPanel" class="panel glass" aria-label="Controls">
    <div class="panel-header">
      <span class="dot dot-green"></span>
      <span class="title">Controls</span>
    </div>
    <div class="controls">
      <div class="slider">
        <div class="row">
          <label for="seaHeight">Wave Height</label>
          <span id="seaHeightVal" class="val">1.6</span>
        </div>
        <input type="range" id="seaHeight" min="0.2" max="5.0" step="0.1" value="1.6">
      </div>
      <div class="slider">
        <div class="row">
          <label for="seaFreq">Wave Freq</label>
          <span id="seaFreqVal" class="val">0.16</span>
        </div>
        <input type="range" id="seaFreq" min="0.05" max="0.5" step="0.01" value="0.16">
      </div>
      <div class="slider">
        <div class="row">
          <label for="seaSpeed">Wave Speed</label>
          <span id="seaSpeedVal" class="val">0.8</span>
        </div>
        <input type="range" id="seaSpeed" min="0.1" max="2.0" step="0.05" value="0.8">
      </div>
      <div class="slider">
        <div class="row">
          <label for="rotateScale">Rotate Scale</label>
          <span id="rotateScaleVal" class="val">2.0</span>
        </div>
        <input type="range" id="rotateScale" min="0.5" max="4.0" step="0.1" value="2.0">
      </div>
      <div class="slider">
        <div class="row">
          <label for="pointSize">Point Size</label>
          <span id="pointSizeVal" class="val">2.0</span>
        </div>
        <input type="range" id="pointSize" min="1.0" max="6.0" step="0.1" value="2.0">
      </div>
      
    </div>
  </div>

  <!-- Loading overlay -->
  <div id="loadingOverlay">
    <div id="loadingBox">
      <div class="spinner" aria-hidden="true"></div>
      <div id="loadingText">Loading WaveGridâ€¦</div>
    </div>
  </div>

  <!-- GUI library removed; using custom controls panel -->

  <!-- highlight.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/languages/glsl.min.js"></script>

  <button id="toggleBtn">Show Code</button>
  <div id="codePanel"><pre><code class="language-glsl" id="shaderCode"></code></pre></div>

  <div id="brandTag">Claire Wang</div>

  <script>
  const canvas = document.getElementById('gl');
  const panel  = document.getElementById('codePanel');
  const toggle = document.getElementById('toggleBtn');
  const codeEl = document.getElementById('shaderCode');
  const overlay = document.getElementById('loadingOverlay');
  const loadingText = document.getElementById('loadingText');
  const gl = canvas.getContext('webgl2', { antialias:false, alpha:false });
  if(!gl){ alert('WebGL2 not supported'); }

  // ================== SHADER SOURCE ===================
  const srcVertex = `#version 300 es
// Vertex shader for WaveGrid point mesh
// Generates a grid of points and displaces them using a simple FBM-like pattern
// then applies subtle camera swing and mouse-driven yaw rotation.

precision highp float;

// Time in seconds since start
uniform float u_time;

// Normalized mouse position (0..1) where x controls yaw
uniform vec2  u_mouse;

// Total number of vertices to draw (square grid assumed)
uniform float u_vertexCount;

// Sea surface parameters (height, frequency, speed)
uniform float u_seaHeight;
uniform float u_seaFreq;
uniform float u_seaSpeed;

// Scene controls
uniform float u_rotateScale;  // mouse yaw multiplier
uniform float u_pointSize;    // gl_PointSize

// Subtle camera swing controls (still present as uniforms)
uniform float u_camSwingAmp;
uniform float u_camSwingSpeed;

// Varyings to the fragment shader
out vec3 v_pos;     // world-ish position after transforms
out float v_height; // height used for coloring

#define POINTSIZE u_pointSize

// Derived grid size (number of points per side)
float g_SIZE;

// Tunables for the procedural surface
const int   ITER_GEOMETRY = 3;      // octaves for displacement
const float SEA_CHOPPY   = 4.0;     // sharpening factor
const mat2  octave_m     = mat2(1.6, 1.2, -1.2, 1.6); // octave warp

// Rotate a vector around Y axis by angle a
vec3 rotateY(vec3 p, float a) {
  float sa = sin(a);
  float ca = cos(a);
  return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);
}

// Hash and value noise helpers
float hash(vec2 p) {
  float h = dot(p, vec2(127.1, 311.7));
  return fract(sin(h) * 43758.5453123);
}

// 2D value noise, returns in [-1, 1]
float noise(vec2 p) {
  vec2 i = floor(p);
  vec2 f = fract(p);
  vec2 u = f * f * (3.0 - 2.0 * f);
  float a = hash(i);
  float b = hash(i + vec2(1.0, 0.0));
  float c = hash(i + vec2(0.0, 1.0));
  float d = hash(i + vec2(1.0, 1.0));
  return -1.0 + 2.0 * mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
}

// A light-weight FBM-like response used to create choppy peaks
float fbm(vec2 uv, float choppy) {
  uv += noise(uv);
  vec2 wv  = 1.0 - abs(sin(uv));
  vec2 swv = abs(cos(uv));
  wv = mix(wv, swv, wv);
  return pow(1.0 - pow(wv.x * wv.y, 0.65), choppy);
}

// Compute the displaced point position for a given vertex id
// H: height scale, F: frequency, S: speed
vec3 GetPoint(float vertexid, float H, float F, float S) {
  // Spacing between points (in world units) derived from grid size
  float SP = 16.0 / g_SIZE;

  // Map the 1D vertex id into 2D grid coordinates (snake pattern per-row)
  float x = mod(vertexid, g_SIZE);
  float y = floor(vertexid / g_SIZE);
  if (mod(y, 2.0) > 0.0) {
    x = g_SIZE - 1.0 - x;
  }

  // Initialize FBM parameters
  float freq = F;
  float amp  = H;
  float choppy = SEA_CHOPPY;

  // Base UV for the grid point; squashed a bit in X to get a nicer aspect
  vec2 uv = vec2((-g_SIZE / 2.0 + x) * SP, (-g_SIZE / 2.0 + y) * SP);
  uv.x *= 0.75;

  // Accumulate height over a few warped octaves, moving over time
  float d;
  float h = 0.0;
  float T = 1.0 + u_time * S;
  for (int i = 0; i < ITER_GEOMETRY; i++) {
    d  = fbm((uv + T) * freq, SEA_CHOPPY);
    d += fbm((uv - T) * freq, SEA_CHOPPY);
    h += d * amp;
    uv   *= octave_m;
    freq *= 1.9;
    amp  *= 0.22;
    choppy = mix(choppy, 1.0, 0.2);
  }

  // Return world-ish position (x, height, z)
  return vec3((-g_SIZE / 2.0 + x) * SP, h, (-g_SIZE / 2.0 + y) * SP);
}

void main() {
  // Derive an even grid side length from total vertex count
  float size = floor(sqrt(u_vertexCount));
  if (mod(size, 2.0) > 0.0) size += 1.0;
  g_SIZE = max(2.0, size);

  // Sample displaced point for this vertex id
  vec3 p = GetPoint(float(gl_VertexID), u_seaHeight, u_seaFreq, u_seaSpeed);

  // Subtle camera swing (x = yaw swing, y = vertical bob)
  float camX = sin(u_time * u_camSwingSpeed) * u_camSwingAmp;
  float camY = cos(u_time * u_camSwingSpeed * 0.7) * u_camSwingAmp * 0.5;
  p = rotateY(p, camX * 0.3);

  // Mouse-driven yaw around Y
  float mx = (u_mouse.x - 0.5) * 2.0;
  p = rotateY(p, -mx * u_rotateScale);

  // Vertical bob and camera offset forward
  p.y += camY * 2.0;
  p += vec3(0.0, -5.0, 15.0);

  // Project: a simple hacky perspective using z in w
  gl_Position = vec4(p.xy * 1.1, 1.0 / (p.z), p.z);
  gl_PointSize = POINTSIZE;

  // Varyings
  v_pos    = p;
  v_height = p.y;
}`;


  const srcFragment = `#version 300 es
// Fragment shader for WaveGrid point sprites
// Colors the points based on their height and renders circular point shapes.

precision mediump float;

in vec3 v_pos;     // from vertex shader
in float v_height; // height for coloring
out vec4 fragColor;

// Simple 3-color gradient based on height
vec3 heightColor(float h) {
  vec3 c1 = vec3(0.0, 0.1, 0.4); // deep blue
  vec3 c2 = vec3(0.1, 0.6, 0.9); // cyan
  vec3 c3 = vec3(1.0, 1.0, 1.0); // white crest
  float t = clamp((h + 5.0) / 10.0, 0.0, 1.0);
  if (t < 0.5) return mix(c1, c2, t * 2.0);
  return mix(c2, c3, (t - 0.5) * 2.0);
}

void main() {
  // Make the point a circle (discard outside unit disc)
  vec2 c = gl_PointCoord * 2.0 - 1.0;
  if (dot(c, c) > 1.0) discard;

  vec3 col = heightColor(v_height);
  fragColor = vec4(col, 1.0);
}`;

  // ============ Compile & Link ==============
  function compile(type,src){
    const s=gl.createShader(type);
    gl.shaderSource(s,src);
    gl.compileShader(s);
    if(!gl.getShaderParameter(s,gl.COMPILE_STATUS))
      throw new Error(gl.getShaderInfoLog(s));
    return s;
  }
  function link(vs,fs){
    const p=gl.createProgram();
    gl.attachShader(p,vs);gl.attachShader(p,fs);gl.linkProgram(p);
    if(!gl.getProgramParameter(p,gl.LINK_STATUS))
      throw new Error(gl.getProgramInfoLog(p));
    return p;
  }

  try{
    const vs=compile(gl.VERTEX_SHADER,srcVertex);
    const fs=compile(gl.FRAGMENT_SHADER,srcFragment);
    const prog=link(vs,fs);
    gl.deleteShader(vs);gl.deleteShader(fs);
    gl.useProgram(prog);
    const vao=gl.createVertexArray();
    gl.bindVertexArray(vao);
    const loc={
      time:gl.getUniformLocation(prog,'u_time'),
      mouse:gl.getUniformLocation(prog,'u_mouse'),
      vcount:gl.getUniformLocation(prog,'u_vertexCount'),
      seaHeight:gl.getUniformLocation(prog,'u_seaHeight'),
      seaFreq:gl.getUniformLocation(prog,'u_seaFreq'),
      seaSpeed:gl.getUniformLocation(prog,'u_seaSpeed'),
      rotateScale:gl.getUniformLocation(prog,'u_rotateScale'),
      pointSize:gl.getUniformLocation(prog,'u_pointSize'),
      camSwingAmp:gl.getUniformLocation(prog,'u_camSwingAmp'),
      camSwingSpeed:gl.getUniformLocation(prog,'u_camSwingSpeed'),
    };
    const COUNT=128*128;
    gl.uniform1f(loc.vcount,COUNT);

    function resize(){
      const dpr=Math.max(1,window.devicePixelRatio||1);
      const w=canvas.clientWidth*dpr,h=canvas.clientHeight*dpr;
      if(canvas.width!==w||canvas.height!==h){canvas.width=w;canvas.height=h;}
      gl.viewport(0,0,gl.drawingBufferWidth,gl.drawingBufferHeight);
    }
    window.addEventListener('resize',resize);resize();

    let mouse={x:.5,y:.5};
    canvas.addEventListener('pointermove',e=>{
      const r=canvas.getBoundingClientRect();
      mouse.x=(e.clientX-r.left)/r.width;
      mouse.y=1.-(e.clientY-r.top)/r.height;
    });

    // Controls state (replaces lil-gui with custom sliders)
    const params={
      seaHeight:1.6, seaFreq:0.16, seaSpeed:0.8,
      rotateScale:2.0, pointSize:2.0,
      camSwingAmp:0.4, camSwingSpeed:0.8
    };

    const bindSlider = (id, key, fmt = (v)=>v.toFixed(2)) => {
      const input = document.getElementById(id);
      const valEl = document.getElementById(id+"Val");
      if(!input||!valEl) return;
      const update = (v) => { params[key] = parseFloat(v); valEl.textContent = fmt(params[key]); };
      update(input.value);
      input.addEventListener('input', e => update(e.target.value));
      input.addEventListener('change', e => update(e.target.value));
    };
    bindSlider('seaHeight','seaHeight', v=>Number(v).toFixed(1));
    bindSlider('seaFreq','seaFreq', v=>Number(v).toFixed(2));
    bindSlider('seaSpeed','seaSpeed', v=>Number(v).toFixed(2));
    bindSlider('rotateScale','rotateScale', v=>Number(v).toFixed(1));
    bindSlider('pointSize','pointSize', v=>Number(v).toFixed(1));

    const t0=performance.now();
    gl.clearColor(0,0,0,1);
    overlay.classList.remove('hidden');
    setTimeout(()=>overlay.classList.add('hidden'),800);

    function frame(){
      const t=(performance.now()-t0)*0.001;
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.useProgram(prog);
      gl.uniform1f(loc.time,t);
      gl.uniform2f(loc.mouse,mouse.x,mouse.y);
      gl.uniform1f(loc.seaHeight,params.seaHeight);
      gl.uniform1f(loc.seaFreq,params.seaFreq);
      gl.uniform1f(loc.seaSpeed,params.seaSpeed);
      gl.uniform1f(loc.rotateScale,params.rotateScale);
      gl.uniform1f(loc.pointSize,params.pointSize);
      gl.uniform1f(loc.camSwingAmp,params.camSwingAmp);
      gl.uniform1f(loc.camSwingSpeed,params.camSwingSpeed);
      gl.drawArrays(gl.POINTS,0,COUNT);
      requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);

    // Code panel logic
    const srcTotal = srcVertex + "\\n\\n// --------------------------\\n\\n" + srcFragment;
    codeEl.textContent = srcTotal;
    hljs.highlightElement(codeEl);

    toggle.addEventListener('click',()=>{
      const open=panel.classList.toggle('open');
      toggle.textContent=open?'Hide Code':'Show Code';
    });

  }catch(err){
    console.error(err);
    loadingText.textContent='Shader error: '+err.message;
  }
  </script>
</body>
</html>
